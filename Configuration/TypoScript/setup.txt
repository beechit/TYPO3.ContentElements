# ***************************************************************************
# Notice: "styles." (and "temp.") objects are UNSET after template parsing!
# Use "lib." for persisting storage of objects.
# ***************************************************************************

# Clear out any constants in this reserved room!
styles.content >

# get content
styles.content.get = CONTENT
styles.content.get {
	table = tt_content
	select.orderBy = sorting
	select.where = colPos=0
	select.languageField = sys_language_uid
}

# get content, left
styles.content.getLeft < styles.content.get
styles.content.getLeft.select.where = colPos=1

# get content, right
styles.content.getRight < styles.content.get
styles.content.getRight.select.where = colPos=2

# get content, margin
styles.content.getBorder < styles.content.get
styles.content.getBorder.select.where = colPos=3

# get news
styles.content.getNews < styles.content.get
styles.content.getNews.select.pidInList = {$styles.content.getNews.newsPid}

# Edit page object:
styles.content.editPanelPage = COA
styles.content.editPanelPage {
	10 = EDITPANEL
	10 {
		allow = toolbar,move,hide
		label.data = LLL:EXT:css_styled_content/pi1/locallang.xml:eIcon.page
		label.wrap = |&nbsp;<b>%s</b>
	}
}











# *********************************************************************
# "lib." objects are preserved from unsetting after template parsing
# *********************************************************************

# Creates a condition for targets. Not allowed in XHTML except for xhtml frames DTD
lib.parseTarget {
	override =
	override.if {
		isTrue.data = TSFE:dtdAllowsFrames
	}
}

# Creates persistent ParseFunc setup for non-HTML content. This is recommended to use (as a reference!)
lib.parseFunc {
	makelinks = 1
	makelinks.http.keep = {$styles.content.links.keep}
	makelinks.http.extTarget < lib.parseTarget
	makelinks.http.extTarget =
	makelinks.http.extTarget.override = {$styles.content.links.extTarget}
	makelinks.mailto.keep = path
	tags {
		link = TEXT
		link {
			current = 1
			typolink.parameter.data = parameters : allParams
			typolink.extTarget < lib.parseTarget
			typolink.extTarget =
			typolink.extTarget.override = {$styles.content.links.extTarget}
			typolink.target < lib.parseTarget
			typolink.target =
			typolink.target.override = {$styles.content.links.target}
			parseFunc.constants =1
		}
	}
	allowTags = {$styles.content.links.allowTags}
	denyTags = *
	sword = <span class="csc-sword">|</span>
	constants = 1

	nonTypoTagStdWrap.HTMLparser = 1
	nonTypoTagStdWrap.HTMLparser {
		keepNonMatchedTags = 1
		htmlSpecialChars = 2
	}
}

# good old parsefunc in "styles.content.parseFunc" is created for backwards compatibility. Don't use it, just ignore.
styles.content.parseFunc < lib.parseFunc

# Creates persistent ParseFunc setup for RTE content (which is mainly HTML) based on the "ts_css" transformation.
lib.parseFunc_RTE < lib.parseFunc
lib.parseFunc_RTE {
	//  makelinks >
	# Processing <table> and <blockquote> blocks separately
	externalBlocks = article, aside, blockquote, div, dd, dl, footer, header, nav, ol, section, table, ul
	externalBlocks {
		# The blockquote content is passed into parseFunc again...
		blockquote.stripNL=1
		blockquote.callRecursive=1
		blockquote.callRecursive.tagStdWrap.HTMLparser = 1
		blockquote.callRecursive.tagStdWrap.HTMLparser.tags.blockquote.overrideAttribs = style="margin-bottom:0;margin-top:0;"

		ol.stripNL=1
		ol.stdWrap.parseFunc = < lib.parseFunc

		ul.stripNL=1
		ul.stdWrap.parseFunc = < lib.parseFunc

		table.stripNL=1
		table.stdWrap.HTMLparser = 1
		table.stdWrap.HTMLparser.tags.table.fixAttrib.class {
			default = contenttable
			always = 1
			list = contenttable
		}
		table.stdWrap.HTMLparser.keepNonMatchedTags = 1
		table.HTMLtableCells=1
		table.HTMLtableCells {
			# Recursive call to self but without wrapping non-wrapped cell content
			default.stdWrap {
				parseFunc =< lib.parseFunc_RTE
				parseFunc.nonTypoTagStdWrap.encapsLines.nonWrappedTag =
			}
			addChr10BetweenParagraphs=1
		}
		div.stripNL = 1
		div.callRecursive = 1

		article < .div
		aside < .div
		footer < .div
		header < .div
		nav < .div
		section < .div

		# Definition list processing
		dl < .div
		dd < .div
	}
	nonTypoTagStdWrap.encapsLines {
		encapsTagList = p,pre,h1,h2,h3,h4,h5,h6,hr,dt
		remapTag.DIV = P
		nonWrappedTag = P
		innerStdWrap_all.ifBlank = &nbsp;
		addAttributes.P.class = bodytext
		addAttributes.P.class.setOnly=blank
	}
	nonTypoTagStdWrap.HTMLparser = 1
	nonTypoTagStdWrap.HTMLparser {
		keepNonMatchedTags = 1
		htmlSpecialChars = 2
	}
}

lib.stdheader >
lib.stdheader = FLUIDTEMPLATE
lib.stdheader {
	file = {$contentelements.view.templateRootPath}Header.html
	partialRootPath = {$contentelements.view.partialRootPath}
	layoutRootPath = {$contentelements.view.layoutRootPath}
}

lib.stdContent >
lib.stdContent = FLUIDTEMPLATE
lib.stdContent {
	file = {$contentelements.view.templateRootPath}Default.html
	partialRootPath = {$contentelements.view.partialRootPath}
	layoutRootPath = {$contentelements.view.layoutRootPath}
}

tt_content >
tt_content = CASE
tt_content {
	key {
		field = CType
	}
	text < lib.stdContent
	text {
		file = {$contentelements.view.templateRootPath}Text.html
	}
}